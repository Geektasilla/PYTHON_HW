Выполнила Бойченко В.А.Итоговый проект: Восстановление работы web сайта и Сервера==========================================================Введение:========Этот документ представляет собой пошаговое руководство по диагностике и восстановлению работоспособности веб-сервера на базе Linux.Мы выступим в роли веб-разработчиков, столкнувшихся с неработающим сайтом, и пройдем весь путь от обнаружения проблемы до ее полного решения и предотвращения в будущем.Описание концепции:==================Я — веб-разработчик, который получил неотложную задачу от заказчика/работодателя - не работает сайт и надо восстановить его работу.Цель проекта:============Необходимо подключиться к серверу и восстановить его работоспособность.Известно, что на сервере работает web-сервер, веб-приложение и настроены бекапы, но по неизвестной причине сервис перестал работать.Разбиваю работу на части, чтобы идти последовательно и выявить неисправности.Часть 1: Диагностика и Восстановление=====================================Прежде чем начинать работу, первым делом нужно: Опросить заказчика происходили ли какие-то работы до обнаружения неисправности.Были ли аналогичные сбои и как давно, если да, то как решились?Пробовал ли кто-то исправить нынешнюю проблему?Что говорит нынешний системный администратор по поводу текущей ситуации?Проверить есть ли подключение к интернету и работает ли все остальное оборудование.Запросить у закзчика пароли и логины.Шаг 1: Проверка доступности сайт================================Первым делом нужно убедиться, что проблема действительно существует. Валидировать проблему. Восстановить работоспособность сайта и далее разбираться с причиной.Открываем в браузере ссылку на сайт http://3.73.79.83/Браузер показывает ошибку в переменной $wgServer = false, по этому веб-сервер не отвечает:"$wgServer must be set in LocalSettings.php. See https://www.mediawiki.org/wiki/Manual:$wgServer" А так как со слов заказчика сайт вчера еще работал, и его никто не трогал, значит надо зайти на сервер и проанализировать что произошло с файлом бэкапов LocalSettings.php.Шаг 2: Подключаемся к серверу=============================Находясь в системе под обычным пользователем выполняем в командной строке команду:ssh -i .ssh/ich.pem ec2-user@3.73.79.83где: 	ssh (Secure Shell) -это протокол, позволяющий безопасно подключаться к удаленным машинам и выполнять на них команды. 	-i ich.pem -флаг указывает путь к файлу с приватным ключом.  	SSH-ключи используются для аутентификации (подтверждения вашей личности) без пароля.  	ec2-user@3.73.79.83 -это имя пользователя (`ec2-user`) и IP-адрес сервера, к которому мы подключаемся.Подверждаем соединение- yesи происходит обмен ключамиДалее смотрим все содержимое домашней директории выполнив команду ls -la, так как со слов заказчика файл LocalSettings.php лежит в ней.где:ls — список файлов.-a — показывает скрытые файлы (которые начинаются с точки). Без этого флага их не видно.-l — показывает подробности (размер, дату изменения и кто хозяин файла).Результат : видим  файл LocalSettings(5).php с пометкой(5), которая говорит нам, что он уже пять раз был скопирован. Шаг 3: Проверяем статус веб-сервера===================================Первым делом нужно узнать, что происходит со службой веб-сервера. Выполняем команду для проверки статуса сервиса:sudo service httpd statusгде: 	sudo -это команда, которая позволяет выполнять другие команды от имени суперпользователя (root), предоставляя необходимые права для 		управления системными службами. 	service — это системная утилита для управления службами (демонами) в операционной системе. Она служит «посредником», который помогает 	запускать, останавливать или проверять состояние программ, работающих в фоновом режиме.	httpd — это имя конкретной службы, в данном случае — веб-сервера Apache. Именно этот процесс отвечает за обработку запросов и выдачу 	веб-страниц пользователям.	status — это параметр (команда), который запрашивает текущее состояние службы. Она покажет, запущен ли сервер в данный момент, активен 	ли он или произошла ошибка.И получаем результат, что сервер активен и уже 23 часа находится в работе:"Active: active (running) since Mon 2026-02-02 08:49:37 UTC; 23h ago"Но возможно это не так. И стоит еще раз проверить. Тогда можно порибегнуть к стандартному протоколу и попробовать его перезагрузить.Шаг 4: Перезапуск веб-сервера=============================Попробуем просто перезапустить сервис и выполняем для запуска командуsudo service httpd restartгде:restart состоит из двух команд (действий): stop — остановить сервис. start — снова запустить сервис.И получаем результат: "Redirecting to /bin/systemctl status httpd.service"Шаг 5: Затем котрольная проверка статуса и сайта================================================Снова проверяем статус сервиса выполнив командуsudo service httpd statusИ получаем результат: что он перезапустился 34 секунды назад. "Active: active (running) since Tue 2026-02-03 08:30:19 UTC; 34s ago"Обновляем страницу сайта в браузере и результат пока остается прежним:"$wgServer must be set in LocalSettings.php. See https://www.mediawiki.org/wiki/Manual:$wgServer"Шаг 6: Прорабатываем верятность новой ошибки расположения файла===============================================================На основании сообщения на сайте можно предположить, что есть вероятность, что из -за  неправильного расположения бэкап файла от 2.04.2024 LocalSettings (5).php возникает ошибка. По этому пробуем переместить файл в нужную нам директорию и набираем команду: cp /home/ec2-user/LocalSettings\ \(5\).php /var/www/ht-bashИ при дальнейших попытках выполнить командy и применить написание с автодополнением по TAB, мы мгновенно сталкиваемся с критической ошибкой.Система нам вывела сообщение "cannot create temp file for hear-document:и команда завершается ошибкой `cp: ... No space left on device".Результат:Эта ошибка — ключ к разгадке. Так какизвестно, что, когда мы используем клавишу табуляции, в bash создается временный файл в tmp, где хэширует наше действие.А у нас вышла ошибка, что на диске сервера  закончилось свободное место и подвисло выполнение команды. Нажимаем  Cntrl+C, останавливаем процесс.И понимаем, что программа, включая веб-сервер, не могут нормально работать без свободного дискового пространства для записи временных файлов, логов и данных.Шаг 7: Проверяем свободное место на диске выполнив команду==========================================================df -hгде:	df (disk free) -это утилита для отображения информации о свободном месте в файловых системах.	-h (human-readable) -это Флаг, который делает вывод команды более читаемым, отображая размеры в килобайтах (K), мегабайтах (M) и 	гигабайтах (G).И в выведеной информацци выделяется строка/dev/nvne0n1p1 10G  10G    20K    100%    /занято 100% дискового пространства.Вывод:это значит, что один из разделов (скорее всего, корневой `/`) использован на `100%`.После чего  наша задача — найти, какие файлы занимают все место.Шаг 8: Поиск "пожирателей" дискового пространства=================================================Применяем команду `find` для поиска файлов размером более 100 мегабайт.sudo find / -type f -size +100M -exec du -h {} \;где:	find / -означает искать файлы, начиная с корневого каталога.	-type f -означает искать только файлы.	-size +100M -означает искать файлы размером более 100 мегабайт.	-exec du -h {} \; -Для каждого найденного файла выполнить команду `du -h` (показать размер в читаемом виде).	{} -заменяется на имя найденного файла.	\; — завершение команды -exec.В результате обнаруживаем среди выведенной информации, три файла огромного размера. И видим что из 10 доступных GB только одним файлом access_log занято 7GB. Это журнал работы web сервера, в который записываются все обращения к серверу. Так называемый архив с отчетом о всех действиях на сервере. Обычно его бэкапят и хранят какое-то время на сервере. 298M /var/log/httpd/log_20260202.tar.gz7.0G /var/log/httpd/access_log-20260202153M /var/log/httpd/log_20260203.tar.gzВывод: файл необходимо удалить, так как он занимает огромную площадь дискового пространства. Шаг 9: Освобождаем место.=========================Выполняем команду:sudo rm -rf /var/log/httpd/access_log-20260202где:sudo -эта команда позволяет выполнить следующую за ней команду от имени суперпользователя (root). Это необходимо для удаления системных файлов или файлов, к которым у пользователя нет доступа.rm -это команда удаления.-rf -где, r для рекурсивного удаления (если это папка),а f для принудительного удаления без подтверждения./var/log/httpd/access_log-20260202: путь к удаляемому файлу (логу веб-сервера Apache).Затем проверяем свободное место еще раз с помощью `df -h`. И теперь выведена информация, о том что место появилось.В следствии удаления получили 79% свободно места на диске.Теперь, когда место есть, вернемся к проблеме с конфигурацией.и пробуем положить данный файл настроек на место, присвоим ему корректное имя.Шаг 10: Восстанавливаем файл конфигурации.==========================================Копируем файл настроек, как мы пытались сделать ранее, но с корректным названием файла:sudo cp "LocalSettings\ \(5\).php" /var/www/html/mediawiki/LocalSettings.phpгде:	cp (copy) — основная команда для копирования файлов или директорий.	"LocalSettings\ \(5\).php" — это файл. Кавычки и обратные слэши нужны, чтобы система правильно прочитала пробелы и скобки в имени 	файла.	/var/www/html/mediawiki/LocalSettings.php -это путь куда копируем ыайл с новым именемРезультат: Копирование прошло успешно. И далее чтобы конфигурационный файл перечитался нужно снова запустить сервер. Для этого выполняем команду:sudo service httpd restartИ видим , что мы успешно рестартовали. Далее смотрим статус, выполнив команду:sudo service httpd  statusИ получаем результат: что он перезапустился 12 секунд назад. "Active: active (running) since Tue 2026-02-03 08:42:22 UTC; 12s ago"Снова обновляем сайт. И получаем ошибку с собщением "This site can't be reached" и ниже видим что IP адрес абсолютно другой 18.153.51.162Это значит, что скорее всего, в файле конфигурации в переменной тоже может быть неверный IP-адрес.Для начала на сайте мы проверяем мануал и смотрим на переменную сервера $wgServer , которая ссыллается на IP-адрес. Затем идем в файл конфигурации.  Шаг 11: Исправляем ошибки в конфигурации.=========================================Открываем файл  LocalSettings.php и исправим в нем IP на корректный, выполнив команду:sudo nano /var/www/html/mediawiki/LocalSettings.phpгде:sudo -позволяет редактировать файл, который требует прав администратора.nano -название простого в использовании текстового редактора для командной строки./var/www/html/mediawiki/LocalSettings.php -путь к основному файлу настроек сайта на MediaWiki.Далее в открытом файле находим строку  с неправильным`$wgServer = "https://18.153.51.162";`и заменяем IP-адрес на актуальный IP-адрес  сервера `$wgServer = "https://3.73.79.83";Сохраняем файл (в `nano` это `Ctrl+X`, затем `Y`, затем `Enter`).Это произошло в связи с тем что виртуальный сервер на Амазон без дополнительной оплаты не дает фиксированный IP адрес, по этому после востановления сервера с вероятностью 90% может произойти замена IP адреса.теперь делаем еще раз рестарт , выполнив команду:sudo systemctl restart httpdгде: 	systemctl - это основная команда для управления системой и службами в современных Linux	Управляет службами: запуск, остановка, перезапуск.	Настраивает автозагрузку: позволяет программам запускаться самим при включении сервера.	Контролирует состояние: показывает подробные логи и ошибки, если служба не работает.Далее проверяем статус, выполнив команду: sudo systemctl status httpdИ видим что статус активный 8 секунд  в работе"Active: active (running) since Tue 2026-02-03 08:52:53 UTC; 8s ago"Снова идем на сайт обновляем страницу в браузере и прописываем нужный IP-адрес в адресную строку.https://3.73.79.83/index.php/Main_Page.После этого видим, что сайт работает.Часть 2: Теперь устраняем первопричины (Log Rotation)=========================================================================После того ка мы восстановили работу сайта, проверяем еще раз накопления логов sudo ls -lah /var/log/httpd/И видим что  access_log опять  быстро растет в связи с тем что его вообще не бекапят.А так же видим файлы с архивами этих логов. И каждый последующий сильно больше предыдущего. Довольно много логов для одного дня.Похоже, что  каждый последующий архив копирует предыдущий бекап и накапливает все.  -rw-r--r-- 1 root root  44K Feb  3 08:56 access_log-rw-r--r-- 1 root root 5.7M Apr  3  2024 log_20240403.tar.gz-rw-r--r-- 1 root root 298M Feb  2 23:59 log_20260202.tar.gz-rw-r--r-- 1 root root 608M Feb  3 08:59 log_20260203.tar.gzА так же при повторно выполненной команде sudo ls -lah /var/log/httpd/ видим в директории обновление файла архивации с интервалом в 2 минуты.-rw-r--r-- 1 root root 608M Feb  3 09:01 log_20260203.tar.gzВывод: Похоже что , уже есть задача для ротации логов, но некорректная. За это отвечает планировщик задач. Шаг 12: Проверяю существующие задачи cron, выполнив команду:============================================================sudo crontab -lгде:	crontab - это команда используется для управления планировщиком задач	-l  ключ выводит на экран текущий список задач, которые запланированны)Результат: находим некорректную запись:* * * * * tar -czf /var/log/httpd/log_$(date +\%Y\%m\%d).tar.gz -C /var/log/httpd .А это значит, что:1.  * * * * * Задание выполняется каждую минуту. Это создает огромную ненужную нагрузку.2.  -C /var/log/httpd  Команда архивирует всю директорию /var/log/httpd, включая создаваемый архив, что приводит к его бесконечному росту.	ключ -С лишний3. Нет очистки: Старый лог-файл (`access\_log`) никогда не удаляется и не обнуляется. Шаг 13:Редактируем crontab ==========================Редактируем crontab от имени root, удалив старую неверную строку и добавив новую. Выполним команду:sudo crontab -eгде:	-e -это ключ, который позволяет редактироват задачи в планировщикеоткрывается редактор VI. Переходим в режим редактирования нажав i, ставим комментарий # на задачу, тем самым ее останавливаем.#* * * * * tar -czf /var/log/httpd/log_$(date +\%Y\%m\%d).tar.gz -C /var/log/httpd .Обязательно все сохраняем  нажав esc  затем:wq  и  enter. Получаем сообщение, что "installing new crontab"Бекап остановлен. Но бэкап access_log файла нам нужен и  грамотное архивирование тоже. По этому надо написать правильный скрипт для решения данной задачи. Шаг 15: Удаляем громоздкие архивы и обнуляем логи=================================================Смотрим на файлы в директорииls -la /var/log/httpd/-rw-r--r-- 1 root root 5.7M Apr  3  2024 log_20240403.tar.gz-rw-r--r-- 1 root root 298M Feb  2 23:59 log_20260202.tar.gz-rw-r--r-- 1 root root 608M Feb  3 08:59 log_20260203.tar.gzsudo su  -приобретаем права root (su -это команда смены пользователя, если не указать имя, то она по умолчаню выбирает  root)и удаляю    все файлы с расширением gz rm -rf /var/log/httpd/*.gzпроверяю снова диреторию и файлы успешно удаленыls -la /var/log/httpd/проверяем еще раз место на диске и видим , что места теперь достаточно df -hзатем обнуляем файл с логами > /var/log/httpd/access_log (отправили ничто в файл, тем самым стерли предыдущюю информацию)Выполняем проверку и файл успешно обнуленls -la /var/log/httpd/Шаг 16: Создаем правильный скрипт для ротации логов===================================================Этот скрипт выполняет резервное копирование логов веб-сервера httpd,очищает старые логи и удаляет старые резервные копии.Создаем и открываем файл: nano backup_log.sh #!/bin/bash## Директория, где лежат логи веб-сервера.LOG_DIR="/var/log/httpd"## Директория, куда будут сохраняться резервные копии.BACKUP_DIR="/home/ec2-user/backup_http"## Срок хранения резервных копий в днях. Файлы старше этого срока будут удалены. Знак "+" означает "старше чем".MAX_BACKUP="+3"## Создаем переменную с текущей датой и временем в формате ГГГГММДД-ЧЧ:ММ:СС.DATE=$(date '+%Y%m%d-%T')## Формируем полное имя и путь для будущего архива.ARCHIVE="$BACKUP_DIR/backup_httpd_log-$DATE.tar.gz"## Команда создает директорию для резервных копий, если она еще не существует.# Флаг -p гарантирует, что не будет ошибки, если директория уже есть.mkdir -p "$BACKUP_DIR"## Архивируем (-c), сжимаем с помощью gzip (-z) и указываем имя файла (-f). В архив помещается все содержимое директории $LOG_DIR.tar -czf "$ARCHIVE" "$LOG_DIR/"## Останавливаем службу httpd, чтобы безопасно очистить файлы логов, в которые сервер может пытаться писать в данный момент.service httpd stop## Удаляем все (*) файлы внутри директории логов. Флаги -r (рекурсивно) и -f (принудительно) обеспечивают удаление без подтверждения.rm -rf "$LOG_DIR"/*## Запускаем службу httpd снова, чтобы сайт продолжил работу.# Сервер начнет писать логи в новые, пустые файлы.service httpd start### Ищем (find) в директории бэкапов ($BACKUP_DIR)# только файлы (-type f)# с именем, начинающимся на "backup_httpd_log*" (-name)# которые были изменены (-mtime) более 3 дней назад ($MAX_BACKUP)# и для каждого найденного файла выполняем (-exec) команду удаления (rm -rf {}).find "$BACKUP_DIR" -type f -name "backup_httpd_log*" -mtime "$MAX_BACKUP" -exec rm -rf {} \;для тестировки в последней строке скрипта можно изменить -exec на -cmin(позволит нам сделать тестовые запуски)В раельной ситуации все операции по отладке скриптов выполнять на резервном сервере или на вашем предназначеннном для таких отладок компьютере. Шаг 17: Запускаем скрипт=========================chmod +x /home/ec2-user/backup_logs.shЗапускаем скрипт ./backup_logs.shИ видим что старые файлы с логами удалились и созданы новые проверяем на наличие  нового архива с логами и он на месте tar -tf backup_http/tar -tf используется для просмотра содержимого архива без его распаковки на диск. Это своего рода «предпросмотр».-t (list) — основной флаг, который приказывает утилите вывести список (оглавление) файлов, находящихся внутри архива.-f (file) — указывает, что далее следует имя файла архива, с которым нужно работать. Без этого флага tar может пытаться обратиться к ленточному накопителю по умолчанию.Шаг 18: Вносим итоговые изменения в crontab===========================================/home/ec2-user/backup_logs.sh Путь к нашему новому скрипту.crontab -e backup_logs.shУдаляем старую задачу и создаем новую. Сначала для тестирования  в процессе отладки используем вариант ниже( запуская задачу каждые 2 минуты.) */2 * * * /home/ec2-user/backup_logs.shСохраняем и выходим. Видим сообщение о том что "installing new crontab". Ждем результат. Видим что все архивы с логами удалились и остался один вновь созданный. В раельной ситуации все операции по отладке скриптов и задач в crontab выполнять на резервном сервере или на вашем предназначеннном для таких отладок компьютере. После успешной отладки заходим в  crontab -e и меняем на желаемый интервал. Сохраняем. 5 3 * * * /home/ec2-user/backup_logs.shПояснение:5 3 * * *  Эта запись означает "выполнять каждый день в 3 часа 05 минут ночи". Этого более чем достаточно для ротации логов.Делаем итоговую контрольную проверку, выполнив команду crontab -l и видим, обновленную задачу.  Все работы по востановлению завершены. Часть 3: Отчет "Post Mortem"=======================================Краткое описание инцидента:Веб-сайт, размещенный на Linux-сервере, стал недоступен. Первичная диагностика показала, что служба веб-сервера Apache (`httpd`) не была запущена. После ручного запуска службы сайт заработал, но отображал ошибку конфигурации и подключения к базе данных.Основные причины инцидента (Root Causes):1.  Переполнение диска: Основной причиной сбоя стало полное исчерпание дискового пространства (`100% usage`) на корневом разделе. Это было вызвано неконтролируемым ростом файла журнала доступа Apache (/var/log/httpd/access_log).2.  Некорректная ротация логов: Существующая задача `cron` для ротации логов была настроена неверно: она выполнялась каждую минуту и архивировала саму себя, не очищая при этом исходный лог-файл.3.  Ошибка конфигурации приложения: В процессе сбоя рабочий файл конфигурации `LocalSettings.php` был утерян из нужной директории. Резервная копия содержала устаревший IP-адрес сервера.Рекомендации по улучшению:1.  Внедрить мониторинг: Настроить систему мониторинга (например, Zabbix, Prometheus) для отслеживания использования дискового пространства и отправки оповещений при достижении пороговых значений (например, 85%).2.  Использовать `logrotate`: Вместо самописных скриптов для ротации логов следует использовать стандартную утилиту `logrotate`, которая является более гибкой, надежной и стандартной для большинства дистрибутивов Linux.3.  Управление конфигурациями: Файлы конфигурации следует хранить в системе контроля версий (например, Git), чтобы отслеживать изменения и иметь возможность быстрого отката.4.  Регулярный аудит: Проводить периодический аудит задач `cron` и других автоматизированных скриптов на сервере для выявления потенциальных проблем.5.  Получить постоянный IP адрес на сервере6.  Все операции по отладке скриптов и задач выполнять на резервном сервере или на вашем предназначеннном для таких отладок компьютере.